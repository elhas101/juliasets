"from juliaset import JuliaSet\nfrom random import uniform, randint\nfrom math import sqrt\nfrom nose import with_setup\n\n###\n# Test Suite for specified JuliaSet interface\n#\n# Run with the command: \"nosetests juliatests.py\"\n###\n\n\n# Custom random numbers\n\ndef rand_range():\n    \"\"\"Return a random complex number bounded by real and imaginary axes [-2, 2]\"\"\"\n    return (uniform(-2,2) + uniform(-2,2)*1j)\n\ndef rand_circle():\n    \"\"\"Return a random complex number within the unit circle\"\"\"\n    r = uniform(-1,1)\n    dr = sqrt(1 - r**2)\n    i = uniform(-dr, dr)\n    return (r + i*1j)\n\n# Test classes for several cases\n    \nclass TestRandomC:\n    \"\"\"Define a julia set with a random c seed value, test interface\"\"\"\n    \n    def setup(self):\n        \"\"\"Setup fixture is run before every test method separately\"\"\"\n        self.c = rand_range()\n        self.n = randint(2,100)\n        self.j = JuliaSet(self.c, self.n)\n        \n    def test_c_value(self): # OK\n        \"\"\"Test that c is an attribute\"\"\"\n        assert self.j.c == self.c\n    \n    def test_n_value(self): # OK \n        \"\"\"Test that n is an attribute\"\"\"\n        assert self.j.n == self.n\n    \n    def test_juliamap(self): # \n        \"\"\"Test that juliamap is implemented properly\"\"\"\n        z = rand_range()\n        print \"z = \", z\n        print \"z**2 = \", z**2\n        zcorrect = z**2 + self.c\n        print \"z**2 + c = \", zcorrect\n        znew = self.j.juliamap(z)\n        print \"juliamap(z) = \", znew\n        assert znew == zcorrect\n    \n    def test_set_spacing(self):\n        \"\"\"Test that changing spacing works\"\"\"\n        print \"Test original spacing _d = 0.001\"\n        assert self.j._d == 0.001\n        print \"Test new spacing of _d = 0.1\"\n        self.j.set_spacing(0.1)\n        print \"_d = \", self.j._d\n        assert self.j._d == 0.1\n        print \"Test that complex plane is regenerated\"\n        print \"len(_complexplane) = \", len(self.j._complexplane)\n        print \"int(4.0 / 0.1)**2 = \", int(4.0 / 0.1)**2\n        assert len(self.j._complexplane) == int(4.0 / 0.1)**2\n    \n    def test_generate(self):\n        \"\"\"Test that generating the julia set works\"\"\"\n        self.j.set_spacing(0.1)\n        self.j.generate()\n        print \"Test that j.set exists, and is of the same length as j._complexplane\"\n        assert (len(self.j.set) == len(self.j._complexplane))\n\nclass TestTrivial:\n    \"\"\"Test that a seed value of c=0 leaves the unit circle invariant\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(0)\n    \n    def test_trivial_seed(self):\n        def check_z(z):\n            \"\"\"Test all z inside unit circle return 0\"\"\"\n            m = TestTrivial.j.iterate(z)\n            print \"m = \", m\n            assert m == 0\n        # A generator like this runs a test for every yield\n        for _ in xrange(100):\n            z = rand_circle()\n            yield check_z, z\n\nclass TestHuge:\n    \"\"\"Test that a huge seed always causes a divergence after 1 iteration\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(16)\n    \n    def test_huge_seed(self):\n        def check_z(z):\n            \"\"\"Test all z escape after 1 iteration\"\"\"\n            print \"z = \", z\n            print \"z**2 = \", z**2\n            print \"z**2 + c = \", z**2 + 16\n            print \"juliamap(z) = \", TestHuge.j.juliamap(z)\n            assert TestHuge.j.iterate(z) == 1\n        # Again, a generator runs a test for every yield\n        for _ in xrange(100):\n            z = rand_range()\n            yield check_z, z\n\n"
{"patch":[[[[0,"ulia"],[-1,"Set "],[1,"\n\n"],[0,"inte"]],149,149,12,10],[[[0,"elf): # "],[1,"OK "],[0,"\n       "]],1165,1165,16,19]],"time":1443515517724}
{"patch":[[[[0,"d Julia\n"],[-1,"\n"],[0,"interfac"]],146,146,17,16]],"time":1443515515721}
{"patch":[[[[0,"ed Julia"],[-1,"\n"],[1,"Set "],[0,"interfac"]],145,145,17,20]],"time":1443515513727}
{"patch":[[[[0,"liamap(self): # "],[-1,"OK "],[0,"\n        \"\"\"Test"]],1159,1159,35,32]],"time":1443514658289}
{"patch":[[[[0,"self): #"],[-1," "],[0,"\n       "]],1166,1166,17,16]],"time":1443514655965}
{"patch":[[[[0,"(self): "],[-1,"#"],[0,"\n       "]],1165,1165,17,16]],"time":1443514653964}
{"patch":[[[[0,"p(self):"],[-1," "],[0,"\n       "]],1164,1164,17,16]],"time":1443514651106}
{"patch":[[[[0,"elf): # "],[-1,"OK"],[0,"\n       "]],937,937,18,16]],"time":1443514647485}
{"patch":[[[[0,"e(self):"],[-1," # "],[0,"\n       "]],934,934,19,16]],"time":1443514645486}
{"patch":[[[[0,": # "],[-1,"OK "],[0,"\n   "]],1050,1050,11,8]],"time":1443514643498}
{"patch":[[[[0,"(self): "],[-1,"# "],[0,"\n       "]],1044,1044,18,16]],"time":1443514641478}
{"patch":[[[[0,"e(self):"],[-1," "],[0,"\n       "]],1043,1043,17,16]],"time":1443514639488}
{"patch":[[[[0,"th as j."],[-1,"_complexplane"],[1,"\n        "],[0,"\"\n      "]],2228,2228,29,25]],"time":1443513653344}
{"patch":[[[[0,"th as j."],[-1,"\n        "],[1,"_complexplane"],[0,"\"\n      "]],2228,2228,25,29]],"time":1443513651375}