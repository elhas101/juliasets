"from juliaset import JuliaSet\nfrom random import uniform, randint\nfrom math import sqrt\nfrom nose import with_setup\n\n###\n# Test Suite for specified JuliaSet interface\n#\n# Run with the command: \"nosetests juliatests.py\"\n###\n\n\n# Custom random numbers\n\ndef rand_range():\n    \"\"\"Return a random complex number bounded by real and imaginary axes [-2, 2]\"\"\"\n    return (uniform(-2,2) + uniform(-2,2)*1j)\n\ndef rand_circle():\n    \"\"\"Return a random complex number within the unit circle\"\"\"\n    r = uniform(-1,1)\n    dr = sqrt(1 - r**2)\n    i = uniform(-dr, dr)\n    return (r + i*1j)\n\n# Test classes for several cases\n    \nclass TestRandomC:\n    \"\"\"Define a julia set with a random c seed value, test interface\"\"\"\n    \n    def setup(self):\n        \"\"\"Setup fixture is run before every test method separately\"\"\"\n        self.c = rand_range()\n        self.n = randint(2,100)\n        self.j = JuliaSet(self.c, self.n)\n        \n    def test_c_value(self): # OK\n        \"\"\"Test that c is an attribute\"\"\"\n        assert self.j.c == self.c\n    \n    def test_n_value(self): # OK \n        \"\"\"Test that n is an attribute\"\"\"\n        assert self.j.n == self.n\n    \n    def test_juliamap(self): # \n        \"\"\"Test that juliamap is implemented properly\"\"\"\n        z = rand_range()\n        print \"z = \", z\n        print \"z**2 = \", z**2\n        zcorrect = z**2 + self.c\n        print \"z**2 + c = \", zcorrect\n        znew = self.j.juliamap(z)\n        print \"juliamap(z) = \", znew\n        assert znew == zcorrect\n    \n    def test_set_spacing(self):\n        \"\"\"Test that changing spacing works\"\"\"\n        print \"Test original spacing _d = 0.001\"\n        assert self.j._d == 0.001\n        print \"Test new spacing of _d = 0.1\"\n        self.j.set_spacing(0.1)\n        print \"_d = \", self.j._d\n        assert self.j._d == 0.1\n        print \"Test that complex plane is regenerated\"\n        print \"len(_complexplane) = \", len(self.j._complexplane)\n        print \"int(4.0 / 0.1)**2 = \", int(4.0 / 0.1)**2\n        assert (self.j._complexplane).size == int(4.0 / 0.1)**2\n    \n    def test_generate(self):\n        \"\"\"Test that generating the julia set works\"\"\"\n        self.j.set_spacing(0.1)\n        self.j.generate()\n        print \"Test that j.set exists, and is of the same length as j._complexplane\"\n        assert (len(self.j.set) == len(self.j._complexplane))\n\nclass TestTrivial:\n    \"\"\"Test that a seed value of c=0 leaves the unit circle invariant\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(0)\n    \n    def test_trivial_seed(self):\n        def check_z(z):\n            \"\"\"Test all z inside unit circle return 0\"\"\"\n            m = TestTrivial.j.iterate(z)\n            print \"m = \", m\n            assert m == 0\n        # A generator like this runs a test for every yield\n        for _ in xrange(100):\n            z = rand_circle()\n            yield check_z, z\n\nclass TestHuge:\n    \"\"\"Test that a huge seed always causes a divergence after 1 iteration\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(16)\n    \n    def test_huge_seed(self):\n        def check_z(z):\n            \"\"\"Test all z escape after 1 iteration\"\"\"\n            print \"z = \", z\n            print \"z**2 = \", z**2\n            print \"z**2 + c = \", z**2 + 16\n            print \"juliamap(z) = \", TestHuge.j.juliamap(z)\n            assert TestHuge.j.iterate(z) == 1\n        # Again, a generator runs a test for every yield\n        for _ in xrange(100):\n            z = rand_range()\n            yield check_z, z\n\n"
{"patch":[[[[-1,"from juliaset import JuliaSet\nfrom random import uniform, randint\nfrom math import sqrt\nfrom nose import with_setup\n\n###\n# Test Suite for specified JuliaSet interface\n#\n# Run with the command: \"nosetests juliatests.py\"\n###\n\n\n# Custom random numbers\n\ndef rand_range():\n    \"\"\"Return a random complex number bounded by real and imaginary axes [-2, 2]\"\"\"\n    return (uniform(-2,2) + uniform(-2,2)*1j)\n\ndef rand_circle():\n    \"\"\"Return a random complex number within the unit circle\"\"\"\n    r = uniform(-1,1)\n    dr = sqrt(1 - r**2)\n    i = uniform(-dr, dr)\n    return (r + i*1j)\n\n# Test classes for several cases\n    \nclass TestRandomC:\n    \"\"\"Define a julia set with a random c seed value, test interface\"\"\"\n    \n    def setup(self):\n        \"\"\"Setup fixture is run before every test method separately\"\"\"\n        self.c = rand_range()\n        self.n = randint(2,100)\n        self.j = JuliaSet(self.c, self.n)\n        \n    def test_c_value(self): # OK\n        \"\"\"Test that c is an attribute\"\"\"\n        assert self.j.c == self.c\n    \n    def test_n_value(self): # OK \n        \"\"\"Test that n is an attribute\"\"\"\n        assert self.j.n == self.n\n    \n    def test_juliamap(self): # \n        \"\"\"Test that juliamap is implemented properly\"\"\"\n        z = rand_range()\n        print \"z = \", z\n        print \"z**2 = \", z**2\n        zcorrect = z**2 + self.c\n        print \"z**2 + c = \", zcorrect\n        znew = self.j.juliamap(z)\n        print \"juliamap(z) = \", znew\n        assert znew == zcorrect\n    \n    def test_set_spacing(self):\n        \"\"\"Test that changing spacing works\"\"\"\n        print \"Test original spacing _d = 0.001\"\n        assert self.j._d == 0.001\n        print \"Test new spacing of _d = 0.1\"\n        self.j.set_spacing(0.1)\n        print \"_d = \", self.j._d\n        assert self.j._d == 0.1\n        print \"Test that complex plane is regenerated\"\n        print \"len(_complexplane) = \", len(self.j._complexplane)\n        print \"int(4.0 / 0.1)**2 = \", int(4.0 / 0.1)**2\n        assert (self.j._complexplane).size == int(4.0 / 0.1)**2\n    \n    def test_generate(self):\n        \"\"\"Test that generating the julia set works\"\"\"\n        self.j.set_spacing(0.1)\n        self.j.generate()\n        print \"Test that j.set exists, and is of the same length as j._complexplane\"\n        assert (len(self.j.set) == len(self.j._complexplane))\n\nclass TestTrivial:\n    \"\"\"Test that a seed value of c=0 leaves the unit circle invariant\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(0)\n    \n    def test_trivial_seed(self):\n        def check_z(z):\n            \"\"\"Test all z inside unit circle return 0\"\"\"\n            m = TestTrivial.j.iterate(z)\n            print \"m = \", m\n            assert m == 0\n        # A generator like this runs a test for every yield\n        for _ in xrange(100):\n            z = rand_circle()\n            yield check_z, z\n\nclass TestHuge:\n    \"\"\"Test that a huge seed always causes a divergence after 1 iteration\"\"\"\n    \n    @classmethod\n    def setup_class(cls):\n        cls.j = JuliaSet(16)\n    \n    def test_huge_seed(self):\n        def check_z(z):\n            \"\"\"Test all z escape after 1 iteration\"\"\"\n            print \"z = \", z\n            print \"z**2 = \", z**2\n            print \"z**2 + c = \", z**2 + 16\n            print \"juliamap(z) = \", TestHuge.j.juliamap(z)\n            assert TestHuge.j.iterate(z) == 1\n        # Again, a generator runs a test for every yield\n        for _ in xrange(100):\n            z = rand_range()\n            yield check_z, z\n\n"]],0,0,3501,0]],"time":1443524751681}